# ecg_preprocess.py

import os
import base64
import uuid
from typing import Dict, Any

import cv2 as cv
import numpy as np
from ecg_image.image_reader import read_ecg_image

# utils-დან ვიღებთ მხოლოდ საჭირო ფუნქციებს
from .utils import inpaint_grid, to_png_bytes

OUTPUT_DIR = "/app/output"
os.makedirs(OUTPUT_DIR, exist_ok=True)

BASE_URL = os.getenv("BASE_URL", "https://your-app-name.onrender.com")

def run_pipeline(image_bytes: bytes, **kwargs) -> Dict[str, Any]:
    # --- Step 1: Save the uploaded image to a temporary file ---
    # The library requires a file path to work with.
    temp_filename = f"{uuid.uuid4()}.png"
    temp_filepath = os.path.join(OUTPUT_DIR, temp_filename)
    
    with open(temp_filepath, "wb") as f:
        f.write(image_bytes)

    rectified_b64, grid_b64, trace_b64 = "", "", ""
    debug_info = {}

    try:
        # --- Step 2: Call the ECG-Image-Kit library ---
        # The library will process the image and save its outputs in the same directory.
        read_ecg_image(temp_filepath, save_path=OUTPUT_DIR, outputs=["grid", "binary"])

        # --- Step 3: Load the results generated by the library ---
        # The library saves the grid mask as 'grid.png' and the trace mask as 'binary.png'
        grid_mask_path = os.path.join(OUTPUT_DIR, "grid.png")
        trace_mask_path = os.path.join(OUTPUT_DIR, "binary.png")

        grid_mask = cv.imread(grid_mask_path, cv.IMREAD_GRAYSCALE) if os.path.exists(grid_mask_path) else None
        trace_mask = cv.imread(trace_mask_path, cv.IMREAD_GRAYSCALE) if os.path.exists(trace_mask_path) else None

        # --- Step 4: Create the rectified color image ---
        # We use the grid mask from the library to inpaint the original color image.
        original_bgr = cv.imdecode(np.frombuffer(image_bytes, np.uint8), cv.IMREAD_COLOR)
        if grid_mask is not None and original_bgr is not None:
            rectified_color = inpaint_grid(original_bgr, grid_mask)
        else:
            rectified_color = original_bgr # Fallback to original if something fails

        # --- Step 5: Encode images to base64 for the response ---
        rectified_b64 = base64.b64encode(to_png_bytes(rectified_color)).decode("utf-8")
        if grid_mask is not None:
            grid_b64 = base64.b64encode(to_png_bytes(grid_mask)).decode("utf-8")
        if trace_mask is not None:
            trace_b64 = base64.b64encode(to_png_bytes(trace_mask)).decode("utf-8")

        # Populate debug info if available
        debug_info = {
            "library_used": "ECG-Image-Kit",
            "grid_mask_found": grid_mask is not None,
            "trace_mask_found": trace_mask is not None
        }

    except Exception as e:
        print(f"Error during ECG-Image-Kit processing: {e}")
        # In case of error, return empty images
        empty_png_b64 = base64.b64encode(to_png_bytes(np.zeros((32, 32), np.uint8))).decode("utf-8")
        rectified_b64, grid_b64, trace_b64 = empty_png_b64, empty_png_b64, empty_png_b64
        debug_info = {"error": str(e)}

    finally:
        # --- Step 6: Clean up temporary files ---
        if os.path.exists(temp_filepath):
            os.remove(temp_filepath)
        if os.path.exists(os.path.join(OUTPUT_DIR, "grid.png")):
            os.remove(os.path.join(OUTPUT_DIR, "grid.png"))
        if os.path.exists(os.path.join(OUTPUT_DIR, "binary.png")):
            os.remove(os.path.join(OUTPUT_DIR, "binary.png"))

    # Return the final JSON response
    return {
        "debug": debug_info,
        "images": {"rectified_png_b64": rectified_b64},
        "masks": {"trace_png_b64": trace_b64, "grid_png_b64": grid_b64},
        "download_urls": {
            "rectified": f"{BASE_URL}/download/rectified.png",
            "grid": f"{BASE_URL}/download/grid.png",
            "trace": f"{BASE_URL}/download/trace.png",
        },
    }
